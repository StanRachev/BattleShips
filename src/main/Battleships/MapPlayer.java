import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.stream.Stream;

public class MapPlayer {
    enum cellState_t {
        Ship_is_hit,
        Ship_is_destroyed,
        missed,
        Already_hit
    }

    final static int MAP_SIZE = 10;

    private static final Cell[][] mapCells = new Cell[MAP_SIZE][MAP_SIZE];
    private static final Cell[][] mapCellsAI = new Cell[MAP_SIZE][MAP_SIZE];

    // Initializing cells with row and column positions
    public void createMap(boolean isAi) {
        int row, col;
        for (row = 0; row < MAP_SIZE; row++) {
            for (col = 0; col < MAP_SIZE; col++) {
                if (isAi) {
                    mapCellsAI[row][col] = new Cell(null, row, col);
                } else {
                    mapCells[row][col] = new Cell(null, row, col);
                }
            }
        }
    }

    public void printMap(boolean isAi) {

        System.out.printf("%n  ");

        // print column numbers from 1 to 10
        Stream.iterate(1, column -> column + 1)
              .limit(MAP_SIZE)
              .forEach(column -> System.out.print(column + "  "));
        System.out.print("\t'=' - fog");

        // print row letters from A to J
        char rowLetter = 'A';
        int row, col;
        for (row = 0; row < MAP_SIZE; row++) {
            System.out.printf("%n" + rowLetter++ + " ");
            // print cell visual
            for (col = 0; col < MAP_SIZE; col++) {
                if (isAi) {
                    System.out.print(mapCellsAI[row][col].getCellVisual() + "  ");
                } else {
                    System.out.print(mapCells[row][col].getCellVisual() + "  ");
                }
            }
            switch (row) {
                case 0 -> System.out.print("\t'*' - miss");
                case 1 -> System.out.print("\t'@' - hit");
            }
        }
        System.out.println();
    }

    public List<Ship> createShips(int areShipsPlacedByPlayer, boolean isAi) {

        List<Ship> shipsList = new ArrayList<>();
        Player player = new Player();

        int[] shipPlaced;

        int row;
        int column;
        int sizeOfShip = 2;

        boolean isShip = false;
        boolean isHorizontal;

        do {
            if ((shipsList.size() == 5 || shipsList.size() == 7 || shipsList.size() == 9) && (isShip)) {
                sizeOfShip++;
            }

            // Player creates ships
            if (areShipsPlacedByPlayer == 1) {
                printUpdatedMap(shipsList);
                listOfShipsToBePlaced(sizeOfShip);
                shipPlaced = shipLocation(player);
            }
            // Randomly generated ships
            else {
                shipPlaced = randomShipLocation();
                populateMap(shipsList, isAi);
            }

            isHorizontal = shipPlaced[0] == 1;
            row = shipPlaced[1];
            column = shipPlaced[2];
            int[] correctedOverlap = isOutsideMap(isHorizontal, row, column, sizeOfShip);
            row = correctedOverlap[0];
            column = correctedOverlap[1];
            isShip = isOverlapping(isHorizontal, row, column, sizeOfShip);

            // Ship is created successfully and is in the list
            if (isShip) {
                shipsList.add(new Ship(isAi, isHorizontal, sizeOfShip, row, column));
            }

            // All 10 ships are in the list
        } while (shipsList.size() != 10);

        // return list of ships
        return shipsList;
    }

    private void printUpdatedMap(List<Ship> newShip) {

        GameManager.wipeScreen();
        populateMap(newShip, false);
        printMap(false);
        printShips(newShip);
    }

    private static void listOfShipsToBePlaced(int size) {

        switch (size) {
            case 2 -> System.out.println("\nPlace 5x Vanguard(2 cells)");
            case 3 -> System.out.println("\nPlace 2x Triumph(3 cells)");
            case 4 -> System.out.println("\nPlace 2x Hercules(4 cells)");
            case 5 -> System.out.println("\nPlace 1x Dreadnought(5 cells)");
        }
    }

    // Player assigns ship position
    private int[] shipLocation(Player player) {

        int[] shipPositionRowCol = player.chooseCell();
        System.out.print("For horizontal press 1, for vertical press 2: ");
        int isHorizontalUser = UI.getChoice(2);
        return new int[]{isHorizontalUser, shipPositionRowCol[0], shipPositionRowCol[1]};
    }

    // Autogenerated ship location
    private static int[] randomShipLocation() {

        final Random random = new Random();
        int isHorizontal = 0;
        int trueFalse = random.nextInt(11);
        if (trueFalse % 2 == 0) {
            isHorizontal = 1;
        }
        return new int[]{isHorizontal, random.nextInt(10), random.nextInt(10)};
    }

    private static int shipLocationOnMap(int rowOrColumn, int size) {

        rowOrColumn -= ((rowOrColumn + (size - 1)) - (MAP_SIZE - 1));
        return rowOrColumn;
    }
    // If ship overstep map boundaries is positioned inside pushed n positions back
    private static int[] isOutsideMap(boolean isHorizontal, int row, int column, int size) {

        if (isHorizontal && (column + (size - 1) > MAP_SIZE - 1)) {
            column = shipLocationOnMap(column, size);
        } else if (!isHorizontal && (row + (size - 1) > MAP_SIZE - 1)) {
            row = shipLocationOnMap(row, size);
        }
        return new int[]{row, column};
    }

    // Checking if current ship overlaps with another ship from the list
    private static boolean isOverlapping(boolean isHorizontal, int row, int column, int size) {

        if (isHorizontal) {
            for (int i = 0; i < size; i++) {
                if (mapCells[row][column++].getBattleship() != null) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (mapCells[row++][column].getBattleship() != null) {
                    return false;
                }
            }
        }
        return true;
    }

    public void populateMap(List<Ship> ships, boolean isAi) {

        for (Ship ship : ships) {
            int row = ship.getRow();
            int column = ship.getColumn();

            if (ship.getSize() >= 1) {
                if (ship.isHorizontal()) {
                    for (int i = 0; i < ship.getSize(); i++) {
                        if (isAi) {
                            mapCellsAI[row][column++].setBattleship(ship);
                        } else {
                            mapCells[row][column++].setBattleship(ship);
                        }
                    }
                } else {
                    for (int i = 0; i < ship.getSize(); i++) {
                        if (isAi) {
                            mapCellsAI[row++][column].setBattleship(ship);
                        } else {
                            mapCells[row++][column].setBattleship(ship);
                        }

                    }
                }
            }
        }
    }

    public cellState_t hit(int row, int column, boolean isAi) {

        Cell cellHit;
        if (isAi) {
            cellHit = mapCellsAI[row][column];
        } else {
            cellHit = mapCells[row][column];
        }

        if (cellHit.getHit()) {
            return cellState_t.Already_hit;
        } else if (cellHit.getBattleship() != null) {
            cellHit.isHit();
            cellHit.getBattleship().reduceHealth(); // Take 1 health
            if (cellHit.getBattleship().getHealth() != 0) { // if ship is hit, but not destroyed
                return cellState_t.Ship_is_hit;
            } else {
                cellHit.getBattleship().setSize(0); // size of Ship is 0
                if (cellHit.getBattleship().getHealth() == 0) {
                    return cellState_t.Ship_is_destroyed;
                }
            }
            return cellState_t.Ship_is_hit;
        } else {
            cellHit.isHit();
            return cellState_t.missed;
        }
    }

    public void printShips(List<Ship> myShips) {

        int cntr;
        String shipName = "";

        System.out.println();
        for (int i = 2; i <= 5; i++) {
            switch (i) {
                case 2 -> shipName = "Vanguard ";
                case 3 -> shipName = "Triumph ";
                case 4 -> shipName = "Hercules ";
                case 5 -> shipName = "Dreadnought";
            }
            cntr = 0;
            for (Ship myShip : myShips) {
                if (myShip.getHealth() == 0) {
                    myShip.setSize(0);
                }
                if (myShip.getSize() == i) {
                    cntr++;
                }
            }
            System.out.printf("(%d)%s     \t   %d %s%n", i,  shipName, cntr, "ships");
        }
    }
}