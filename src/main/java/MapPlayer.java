import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Random;
import java.util.Scanner;
import java.util.stream.Stream;

public class MapPlayer {
    enum cellState_t {
        Ship_is_hit,
        Ship_is_destroyed,
        missed,
        Already_hit
    }

    final static int MAP_SIZE = 10;

    private static final Cell[][] mapCells = new Cell[MAP_SIZE][MAP_SIZE];

    public void createMap() {

        int row, col;
        for (row = 0; row < MAP_SIZE; row++) {
            for (col = 0; col < MAP_SIZE; col++) {
                mapCells[row][col] = new Cell(null, row, col);
            }
        }
    }

    public void printMap() {

        System.out.printf("%n  ");

        // print column numbers from 1 to 10
        /*System.out.println(IntStream.range(1, 10)
                                    .sorted() + "  ");*/
        Stream.iterate(1, column -> column + 1)
              .limit(MAP_SIZE)
              .forEach(column -> System.out.print(column + "  "));
        System.out.print("\t'=' - fog");

        // print row letters from A to J
        char rowLetter = 'A';
        int row, col;
        for (row = 0; row < MAP_SIZE; row++) {
            System.out.printf("%n" + rowLetter++ + " ");
            // print cell visual
            for (col = 0; col < MAP_SIZE; col++) {
                System.out.print(mapCells[row][col].getCellVisual() + "  ");
            }
            switch (row) {
                case 0 -> System.out.print("\t'â–„' - miss");
                case 1 -> System.out.print("\t'@' - hit");
            }
        }
        System.out.println();
    }

    public List<Ship> createShips(int shipPlacement, boolean isAI) throws IOException, InterruptedException {

        List<Ship> shipsList = new ArrayList<>();
        Player player = new Player();

        int[] shipPlaced;

        int row;
        int column;
        int sizeOfShip = 2;

        boolean isShip = false;
        boolean isHorizontal;
        boolean isFullList = false;

        while (!isFullList) {

            if ((shipsList.size() == 5 || shipsList.size() == 7 || shipsList.size() == 9) && isShip) {
                sizeOfShip++;
            }
            if (shipPlacement == 1) { // Player creates ships
                printUpdatedMap(shipsList);
                listOfShipsToPlace(sizeOfShip);
                shipPlaced = shipLocation(player);
            } else { // Randomly generated ships
                shipPlaced = randomShipLocation();
                populateMap(shipsList);
            }
            isHorizontal = shipPlaced[0] == 1;
            row = shipPlaced[1];
            column = shipPlaced[2];
            int[] shipCorrectedLocation = checkShipOverstepMap(isHorizontal, row, column, sizeOfShip);
            row = shipCorrectedLocation[0];
            column = shipCorrectedLocation[1];
            isShip = checkOverlappingShips(isHorizontal, row, column, sizeOfShip);

            if (isShip) { // Ship is created successfully and is in the list
                shipsList.add(new Ship(isAI, isHorizontal, sizeOfShip, row, column));
            }
            if (shipsList.size() == 10) { // All 10 ships are in the list
                isFullList = true;
            }
        }
        return shipsList; // return list of ships
    }

    private void printUpdatedMap(List<Ship> newShip) throws IOException, InterruptedException {

        Game.wipeScreen();
        populateMap(newShip);
        printMap();
        printShips(newShip);
    }

    private static void listOfShipsToPlace(int size) {

        switch (size) {
            case 2 -> System.out.println("\nPlace 5x Vanguard(2 cells)");
            case 3 -> System.out.println("\nPlace 2x Triumph(3 cells)");
            case 4 -> System.out.println("\nPlace 2x Hercules(4 cells)");
            case 5 -> System.out.println("\nPlace 1x Dreadnought(5 cells)");
        }
    }
    // Player assigns ship position
    private static int[] shipLocation(Player player) {

        Scanner scan = new Scanner(System.in);
        int[] shipPositionRowCol = player.cellPosition();
        System.out.print("For horizontal press 1, for vertical press 2: ");
        int isHorizontalUser = scan.nextInt();
        return new int[]{isHorizontalUser, shipPositionRowCol[0], shipPositionRowCol[1]};
    }
    // Autogenerated ship location
    private static int[] randomShipLocation() {

        final Random random = new Random();
        int isHorizontal = 0;
        int trueFalse = random.nextInt(11);
        if (trueFalse % 2 == 0) {
            isHorizontal = 1;
        }
        return new int[]{isHorizontal, random.nextInt(10), random.nextInt(10)};
    }

    private static int shipLocationOnMap(int rowOrColumn, int size) {

        rowOrColumn -= ((rowOrColumn + (size - 1)) - (MAP_SIZE - 1));
        return rowOrColumn;
    }
    // If ship overstep map boundaries is positioned inside pushed n positions back
    private static int[] checkShipOverstepMap(boolean isHorizontal, int row, int column, int size) {

        if (isHorizontal && (column + (size - 1) > MAP_SIZE - 1)) {
            column = shipLocationOnMap(column, size);
        } else if (!isHorizontal && (row + (size - 1) > MAP_SIZE - 1)) {
            row = shipLocationOnMap(row, size);
        }
        return new int[]{row, column};
    }

    // Checking if current ship overlaps with another ship from the list
    private static boolean checkOverlappingShips(boolean isHorizontal, int row, int column, int size) {

        if (isHorizontal) {
            for (int i = 0; i < size; i++) {
                if (mapCells[row][column++].getBattleship() != null) {
                    return false;
                }
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (mapCells[row++][column].getBattleship() != null) {
                    return false;
                }
            }
        }
        return true;
    }

    public void populateMap(List<Ship> ships) {

        for (Ship ship : ships) {
            int row = ship.getRow();
            int column = ship.getColumn();

            if (ship.getSize() >= 1) {
                if (ship.isHorizontal()) {
                    for (int i = 0; i < ship.getSize(); i++) {
                        mapCells[row][column++].setBattleship(ship);
                    }
                } else {
                    for (int i = 0; i < ship.getSize(); i++) {
                        mapCells[row++][column].setBattleship(ship);
                    }
                }
            }
        }
    }

    public cellState_t hit(int row, int column) {

        Cell cellHit = mapCells[row][column];
        if (cellHit.getHit()) {
            return cellState_t.Already_hit;
        } else if (cellHit.getBattleship() != null) {
            cellHit.isHit();
            cellHit.getBattleship().reduceHealth(); // Take 1 health
            if (cellHit.getBattleship().getHealth() != 0) { // if ship is hit, but not destroyed
                return cellState_t.Ship_is_hit;
            } else {
                cellHit.getBattleship().setSize(0); // size of Ship is 0
                if (cellHit.getBattleship().getHealth() == 0) {
                    return cellState_t.Ship_is_destroyed;
                }
            }
            return cellState_t.Ship_is_hit;
        } else {
            cellHit.isHit();
            return cellState_t.missed;
        }
    }

    public void printShips(List<Ship> myShips) {

        int cntr;
        String shipName = "";

        System.out.println();
        for (int i = 2; i <= 5; i++) {
            switch (i) {
                case 2 -> shipName = "Vanguard ";
                case 3 -> shipName = "Triumph ";
                case 4 -> shipName = "Hercules ";
                case 5 -> shipName = "Dreadnought";
            }
            cntr = 0;
            for (Ship myShip : myShips) {
                if (myShip.getHealth() == 0) {
                    myShip.setSize(0);
                }
                if (myShip.getSize() == i) {
                    cntr++;
                }
            }
            System.out.printf("(%d)%s     \t   %d %s%n", i,  shipName, cntr, "ships");
        }
    }
}

class MapAI extends MapPlayer {

    private static final Cell[][] mapCellsAI = new Cell[MAP_SIZE][MAP_SIZE];

    @Override
    public void createMap() {

        int i, j;

        for (i = 0; i < MAP_SIZE; i++) {
            for (j = 0; j < MAP_SIZE; j++) {
                mapCellsAI[i][j] = new Cell(null, i, j);
            }
        }
    }

    @Override
    public void printMap() {

        int row, col;

        System.out.printf("%n  ");

        // print column numbers from 1 to 10
        Stream.iterate(1, column -> column + 1)
              .limit(MAP_SIZE)
              .forEach(column -> System.out.print(column + "  "));

        // print row letters from A to J
        char rowLetters = 'A';
        for (row = 0; row < MAP_SIZE; row++) {
            System.out.printf("%n" + rowLetters++ + " ");
            // print cell visual
            for (col = 0; col < mapCellsAI.length; col++) {
                System.out.print(mapCellsAI[row][col].getCellVisual() + "  "); // print fog '=' for every cell
            }
        }
        System.out.println();
    }

    @Override
    public void populateMap(List<Ship> ships) {

        for (Ship ship : ships) {
            int row = ship.getRow();
            int column = ship.getColumn();

            if (ship.getSize() >= 1) {
                if (ship.isHorizontal()) {
                    for (int i = 0; i < ship.getSize(); i++) {
                        mapCellsAI[row][column++].setBattleship(ship);
                    }
                } else {
                    for (int i = 0; i < ship.getSize(); i++) {
                        mapCellsAI[row++][column].setBattleship(ship);
                    }
                }
            }
        }
    }

    @Override
    public cellState_t hit(int row, int column) {

        Cell cellHit = mapCellsAI[row][column];
        if (cellHit.getHit()) {
            return cellState_t.Already_hit;
        } else if (cellHit.getBattleship() != null) {
            cellHit.isHit();
            cellHit.getBattleship().reduceHealth(); // Take 1 health
            if (cellHit.getBattleship().getHealth() != 0) { // if ship is hit, but not destroyed
                return cellState_t.Ship_is_hit;
            } else {
                cellHit.getBattleship().setSize(0); // size of Ship is 0
                if (cellHit.getBattleship().getHealth() == 0) {
                    return cellState_t.Ship_is_destroyed;
                }
            }
            return cellState_t.Ship_is_hit;
        } else {
            cellHit.isHit();
            return cellState_t.missed;
        }
    }
}